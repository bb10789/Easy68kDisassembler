00001000 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 11/20/2020 8:13:47 PM

00000000                             1  *-----------------------------------------------------------
00000000                             2  * Title      :
00000000                             3  * Written by :
00000000                             4  * Date       :
00000000                             5  * Description:
00000000                             6  *-----------------------------------------------------------
00001000                             7      ORG    $1000
00001000                             8  *=================================================================
00001000                             9  *                     THIS IS OUR MAIN METHOD
00001000                            10  *               Don't throw random stuff in it, keep it to a minimum
00001000                            11  
00001000                            12  START:                  ; first instruction of program
00001000  4EB9 00001006             13          JSR     GETINPUT
00001006                            14  *=================================================================
00001006                            15  *---------------Get starting and ending addresss------- Kelvin
00001006                            16  *--------------- PRE: will be using D0, D5, A1
00001006                            17  *----------------Post: Address will be stored in addrStart and addrEnd
00001006                            18  GETINPUT:
00001006  43F9 00001254             19          LEA     WELCOME, A1
0000100C  103C 000E                 20          MOVE.B  #14,    D0
00001010  4E4F                      21          TRAP    #15
00001012  327C 0000                 22          MOVEA   #$0, A1 // Clear A1 to prevent screen freeze
00001016  103C 0002                 23          MOVE.B  #2,D0
0000101A  4E4F                      24          TRAP    #15
0000101C  2801                      25          MOVE.L  D1, D4   // Move input length into D4, See Convert Pre conditon
0000101E  7000                      26          MOVE.L  #$0, d0  // intitiate counter
00001020  4EB9 00001072             27          JSR     LOOP    // Convert starting address into hex
00001026  23C5 000012B6             28          MOVE.L  D5, addrStart
0000102C  43F9 00001274             29          LEA     WELCOME2, A1
00001032  103C 000E                 30          MOVE.B  #14,    D0
00001036  4E4F                      31          TRAP    #15
00001038  327C 0000                 32          MOVEA   #$0, A1 // Clear A1 to prevent screen freeze
0000103C  103C 0002                 33          MOVE.B  #2,D0
00001040  4E4F                      34          TRAP    #15
00001042  23C5 000012BA             35          MOVE.L  D5, addrEnd
00001048  4245                      36          CLR     D5       // Clear D5 for exit address
0000104A  1801                      37          MOVE.B  D1, D4   // Move input length into D4, See Convert Pre conditon
0000104C  103C 0000                 38          MOVE.B  #$0, d0  // intitiate counter
00001050  4EB9 00001072             39          JSR     LOOP    // Convert Ending address int Hex
00001056  31FC 2200 6000            40          MOVE.W  #$2200, $6000 // MOVE.L D0, D1, used for testing only
0000105C  45F8 6000                 41          LEA $6000, A2 //testing
00001060  4EB9 000010EE             42          JSR     OPCODE
00001066  4EF9 0000106C             43          JMP     END
0000106C                            44  END:
0000106C  103C 0009                 45          MOVE.B  #9, D0
00001070  4E4F                      46          TRAP    #15
00001072                            47  LOOP
00001072  B880                      48          CMP.L   D0, D4  // Loop until length of word reached
00001074  6E00 0004                 49          BGT     CONVERT
00001078  4E75                      50          RTS 
0000107A                            51  
0000107A                            52  *=================================================================
0000107A                            53  *---------------NUMBER CONVERSION FROM INPUT TO HEX------- Kelvin
0000107A                            54  *PRE      D4 must contain input length, d0 must be 0
0000107A                            55  *POST     D5 WILL CONTAIN ADDRESS VALUE IN HEX        
0000107A                            56  CONVERT:
0000107A  5280                      57          ADDQ.L  #$1, D0 // increment counter
0000107C  1211                      58          move.b  (A1),D1    // Get next bit from Input
0000107E  5289                      59          adda.L  #1, A1      // Increment Input
00001080  0401 0030                 60          sub.b   #$30,D1     //
00001084  B23C 0010                 61          cmp.b   #$10,D1   // Check if value is larger than 10
00001088  6E00 000A                 62          bgt     CHAR      // Find Hex
0000108C  1401                      63          move.b  D1, D2    // IF it is less than 10
0000108E  4EF9 000010C4             64          JMP     ADDVAL        
00001094                            65  CHAR:
00001094  B23C 0011                 66          CMP.B   #$11, D1 // Convert each hex into an appropriate hex
00001098  6700 0030                 67          BEQ     A
0000109C  B23C 0012                 68          CMP.B   #$12, D1
000010A0  6700 002E                 69          BEQ     B
000010A4  B23C 0013                 70          CMP.B   #$13, D1
000010A8  6700 002C                 71          BEQ     C
000010AC  B23C 0014                 72          CMP.B   #$14, D1
000010B0  6700 002A                 73          BEQ     D
000010B4  B23C 0015                 74          CMP.B   #$15, D1
000010B8  6700 0028                 75          BEQ     E
000010BC  B23C 0016                 76          CMP.B   #$16, D1
000010C0  6700 0026                 77          BEQ     F
000010C4                            78  
000010C4                            79  ADDVAL:
000010C4  E98D                      80          lsl.l    #$4, D5 // Shift based on position
000010C6  DA82                      81          add.l    D2, D5 //Add value into Input
000010C8  60A8                      82          BRA      LOOP
000010CA                            83      
000010CA                            84  A:
000010CA  740A                      85          MOVE.L  #$A, D2 
000010CC  4EF8 10C4                 86          jmp ADDVAL
000010D0                            87  B:
000010D0  740B                      88          MOVE.L  #$B, D2
000010D2  4EF8 10C4                 89          jmp ADDVAL
000010D6                            90  C:
000010D6  740C                      91          MOVE.L  #$C, D2
000010D8  4EF8 10C4                 92          jmp ADDVAL
000010DC                            93  D:
000010DC  740D                      94          MOVE.L  #$D, D2
000010DE  4EF8 10C4                 95          jmp ADDVAL
000010E2                            96  E:
000010E2  740E                      97          MOVE.L  #$E, D2
000010E4  4EF8 10C4                 98          jmp ADDVAL
000010E8                            99  F:
000010E8  740F                     100          MOVE.L  #$F, D2
000010EA  4EF8 10C4                101          jmp ADDVAL
000010EE                           102          
000010EE                           103  *=======================================================================
000010EE                           104  *---------Find the first 4 of instruction and determines the instruction
000010EE                           105  OPCODE:
000010EE  4EB9 00001242            106          JSR     CLRREG
000010F4  3212                     107          MOVE.W  (A2), D1
000010F6  2401                     108          MOVE.L  D1, D2  //D2 now containse the opperand EA!!!
000010F8  E849                     109          LSR.W   #4, D1
000010FA  E849                     110          LSR.W   #4, D1
000010FC  E849                     111          LSR.W   #4, D1  //Right Shift 3 times
000010FE  1001                     112          MOVE.B  D1, D0  // OPCODE FOUND
00001100  C0FC 0006                113          MULU    #6, D0
00001104  45F9 0000110E            114          LEA     JMPTABLE, A2
0000110A  4EF2 0000                115          JMP     (A2, D0)
0000110E                           116          
0000110E                           117  *========================================================================
0000110E                           118  *--------Jump table used for different opcode!!! Please orgainze well using decimal
0000110E                           119  *------- Add your instructions here
0000110E                           120  JMPTABLE
0000110E  4EF9 00001120            121          JMP     OP0000
00001114  4EF9 00001120            122          JMP     OP0001
0000111A  4EF9 00001120            123          JMP     OP0010 
00001120                           124           
00001120                           125  OP0000:
00001120                           126  OP0001:
00001120                           127  * -> MOVE.L
00001120                           128  * Printed using MOVEL String as a variable on the very bottom
00001120                           129  OP0010:
00001120  43F9 00001295            130          LEA     MOVEL, A1
00001126  103C 000E                131          MOVE.B  #14, D0
0000112A  4E4F                     132          TRAP    #15
0000112C  6000 0002                133          BRA     EA
00001130                           134          
00001130                           135          
00001130                           136          
00001130                           137  * EA STARTS HERE!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
00001130                           138  *=================================================================
00001130                           139  *-----------EA-- Calculate EA used for Data Registers
00001130                           140  *----------Pre: D2, D0, D1 must be clear
00001130                           141  *----------POST: prints out EA, D0 will store Data Register #, D1 will store EA MODE
00001130                           142  EA:
00001130  E18A                     143          LSL.L   #8, D2 // Remove first 20 bits to get opperand
00001132  E18A                     144          LSL.L   #8, D2
00001134  E98A                     145          LSL.L   #4, D2
00001136  E08A                     146          LSR.L   #8, D2
00001138  E08A                     147          LSR.L   #8, D2
0000113A  E88A                     148          LSR.L   #4, D2 // 12 bits of opperand found
0000113C  1002                     149          MOVE.B  D2, D0 Source Data Register
0000113E  EB08                     150          LSL.B   #5, D0
00001140  EA08                     151          LSR.B   #5, D0
00001142  1202                     152          MOVE.B  D2, D1 *Source Data Mode
00001144  E509                     153          LSL.B   #2, D1
00001146  EA09                     154          LSR.B   #5, D1
00001148                           155  *=================================================
00001148                           156  *-----------EA CHECKER------Continues from EA
00001148                           157  *-----------Pre: D1 must contain the Mode of EA        
00001148                           158  * TODO: ERROR CHECKING, OTHER MODES other than D0
00001148                           159  EACHECKER: 
00001148  B23C 0000                160          CMP.B   #$000, D1
0000114C  6700 0002                161          BEQ     JMPTOSRCREG
00001150                           162  JMPTOSRCREG:
00001150  43F9 0000118E            163          LEA     DATAREGTABLE, A1
00001156  C0FC 0006                164          MULU    #6, D0  * Multiply by 6 bc Each index between jmp table diff is 6
0000115A  4EB1 0000                165          JSR     (A1, D0) *JMP To index A1 + D0
0000115E                           166          * EA CONTINUES HERE
0000115E  4EB9 00001234            167          JSR     PRINTCOMMA  * Prints comma between two operrands
00001164  EC8A                     168          LSR.L   #6, D2 *Shift away all Source bits, leaving dest and opcode 
00001166  4241                     169          CLR     D1     * Clear D1 and D0 for opperand mode and register
00001168  4240                     170          CLR     D0
0000116A  1202                     171          MOVE.B  D2, D1 * Prepare D1 for Mode
0000116C  EB09                     172          LSL.B   #5, D1  * Shift 5 bits to get rid of Register and size
0000116E  EA09                     173          LSR.B   #5, D1
00001170  1002                     174          MOVE.B  D2, D0  *Prepare D0 for Register
00001172  E508                     175          LSL.B   #2, D0
00001174  EA08                     176          LSR.B   #5, D0
00001176  B23C 0000                177          CMP.B   #$000, D1 * EA CHECKS BEGIN
0000117A  6700 0002                178          BEQ     JMPTODESTREG
0000117E                           179  JMPToDestReg: *PRINT OUT DEST Registers
0000117E  43F9 0000118E            180          LEA     DATAREGTABLE, A1
00001184  C0FC 0006                181          MULU    #6, D0 * Multiply by 6 bc Each index between jmp table diff is 6
00001188  4EB1 0000                182          JSR     (A1, D0) *JMP to A1 + D0
0000118C  4E75                     183          RTS
0000118E                           184          
0000118E                           185  
0000118E                           186          
0000118E                           187  *=================================================================
0000118E                           188  *---------Data Register Table used for printing out Registers----
0000118E                           189  *----------Starts from index and use JRS (x,y) to jump to certain index, multiply by #6
0000118E                           190  DataRegTable
0000118E  4EF9 000011BE            191          JMP REG_D0
00001194  4EF9 000011D2            192          JMP REG_D1
0000119A  4EF9 000011E0            193          JMP REG_D2
000011A0  4EF9 000011EE            194          JMP REG_D3
000011A6  4EF9 000011FC            195          JMP REG_D4
000011AC  4EF9 0000120A            196          JMP REG_D5
000011B2  4EF9 00001218            197          JMP REG_D6
000011B8  4EF9 00001226            198          JMP REG_D7
000011BE                           199          
000011BE                           200  REG_D0:
000011BE  227C 00000000            201          MOVEA.L #$0, A1
000011C4  43F9 0000129D            202          LEA     DREG0, A1
000011CA  103C 000E                203          MOVE.B  #14, D0
000011CE  4E4F                     204          TRAP    #15
000011D0  4E75                     205          RTS
000011D2                           206          
000011D2                           207  REG_D1:
000011D2  43F9 000012A0            208          LEA     DREG1, A1
000011D8  103C 000E                209          MOVE.B  #14, D0
000011DC  4E4F                     210          TRAP    #15
000011DE  4E75                     211          RTS
000011E0                           212  REG_D2:
000011E0  43F9 000012A3            213          LEA     DREG2, A1
000011E6  103C 000E                214          MOVE.B  #14, D0
000011EA  4E4F                     215          TRAP    #15
000011EC  4E75                     216          RTS
000011EE                           217  REG_D3:
000011EE  43F9 000012A6            218          LEA     DREG3, A1
000011F4  103C 000E                219          MOVE.B  #14, D0
000011F8  4E4F                     220          TRAP    #15
000011FA  4E75                     221          RTS
000011FC                           222  REG_D4:
000011FC  43F9 000012A9            223          LEA     DREG4, A1
00001202  103C 000E                224          MOVE.B  #14, D0
00001206  4E4F                     225          TRAP    #15
00001208  4E75                     226          RTS
0000120A                           227  REG_D5:
0000120A  43F9 000012AC            228          LEA     DREG5, A1
00001210  103C 000E                229          MOVE.B  #14, D0
00001214  4E4F                     230          TRAP    #15
00001216  4E75                     231          RTS
00001218                           232  REG_D6:
00001218  43F9 000012AF            233          LEA     DREG6, A1
0000121E  103C 000E                234          MOVE.B  #14, D0
00001222  4E4F                     235          TRAP    #15
00001224  4E75                     236          RTS
00001226                           237  REG_D7:
00001226  43F9 000012B2            238          LEA     DREG7, A1
0000122C  103C 000E                239          MOVE.B  #14, D0
00001230  4E4F                     240          TRAP    #15
00001232  4E75                     241          RTS
00001234                           242          
00001234                           243  PRINTCOMMA: * Prints comma between two operrands
00001234  43F9 00001292            244          LEA     COMMA, A1
0000123A  103C 000E                245          MOVE.B  #14, D0
0000123E  4E4F                     246          TRAP    #15
00001240  4E75                     247          RTS
00001242                           248          
00001242                           249  
00001242                           250          
00001242                           251          
00001242                           252          
00001242                           253           
00001242                           254  * Clear all registers    
00001242                           255  CLRREG:
00001242  4241                     256      CLR D1
00001244  4242                     257      CLR D2
00001246  4243                     258      CLR D3
00001248  4244                     259      CLR D4
0000124A  4245                     260      CLR D5
0000124C  4246                     261      CLR D6
0000124E  4E75                     262      RTS
00001250                           263      
00001250                           264      
00001250                           265          
00001250                           266  * Put program code here
00001250                           267  
00001250  FFFF FFFF                268      SIMHALT             ; halt simulator
00001254                           269  
00001254                           270  * Put variables and constants here
00001254  =0000000D                271  CR  EQU $0D
00001254  =0000000A                272  LF  EQU $0A
00001254= 50 6C 65 61 73 65 ...    273  WELCOME     DC.B    'Please enter starting address',CR, LF, 0
00001274= 50 6C 65 61 73 65 ...    274  WELCOME2    DC.B    'Please enter ending address',CR, LF, 0
00001292                           275  
00001292= 2C 20 00                 276  COMMA       DC.B    ', ', 0
00001295                           277  
00001295                           278  
00001295= 4D 4F 56 45 2E 4C ...    279  MOVEL       DC.B    'MOVE.L ', 0
0000129D                           280  
0000129D                           281  
0000129D                           282  *DATA REGISTERS PRINTOUT
0000129D= 44 30 00                 283  DREG0       DC.B    'D0', 0
000012A0= 44 31 00                 284  DREG1       DC.B    'D1', 0
000012A3= 44 32 00                 285  DREG2       DC.B    'D2', 0
000012A6= 44 33 00                 286  DREG3       DC.B    'D3', 0
000012A9= 44 34 00                 287  DREG4       DC.B    'D4', 0
000012AC= 44 35 00                 288  DREG5       DC.B    'D5', 0
000012AF= 44 36 00                 289  DREG6       DC.B    'D6', 0
000012B2= 44 37 00                 290  DREG7       DC.B    'D7', 0 
000012B5                           291  
000012B5                           292  
000012B6= 00000001                 293  addrStart   DC.L    1   // Starting address
000012BA= 00000001                 294  addrEnd     DC.L    1   // ending address
000012BE                           295      END    START        ; last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A                   10CA
ADDREND             12BA
ADDRSTART           12B6
ADDVAL              10C4
B                   10D0
C                   10D6
CHAR                1094
CLRREG              1242
COMMA               1292
CONVERT             107A
CR                  D
D                   10DC
DATAREGTABLE        118E
DREG0               129D
DREG1               12A0
DREG2               12A3
DREG3               12A6
DREG4               12A9
DREG5               12AC
DREG6               12AF
DREG7               12B2
E                   10E2
EA                  1130
EACHECKER           1148
END                 106C
F                   10E8
GETINPUT            1006
JMPTABLE            110E
JMPTODESTREG        117E
JMPTOSRCREG         1150
LF                  A
LOOP                1072
MOVEL               1295
OP0000              1120
OP0001              1120
OP0010              1120
OPCODE              10EE
PRINTCOMMA          1234
REG_D0              11BE
REG_D1              11D2
REG_D2              11E0
REG_D3              11EE
REG_D4              11FC
REG_D5              120A
REG_D6              1218
REG_D7              1226
START               1000
WELCOME             1254
WELCOME2            1274
